{"version":3,"file":"432.20e0779b7ab1bb47c229.js","mappings":"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","sources":["webpack://mytonwallet/./src/util/fetch.ts","webpack://mytonwallet/./src/api/chains/ton/util/tonCore.ts","webpack://mytonwallet/./src/api/common/utils.ts","webpack://mytonwallet/./src/util/compareVersions.ts","webpack://mytonwallet/./src/util/ledger/index.ts"],"sourcesContent":["import {\n  BRILLIANT_API_BASE_URL, DEFAULT_ERROR_PAUSE, DEFAULT_RETRIES, DEFAULT_TIMEOUT,\n} from '../config';\nimport { ApiServerError } from '../api/errors';\nimport { logDebug } from './logs';\nimport { pause } from './schedulers';\n\ntype QueryParams = Record<string, string | number | boolean | string[]>;\n\nconst MAX_TIMEOUT = 30000; // 30 sec\n\nexport async function fetchJsonWithProxy(url: string | URL, data?: QueryParams, init?: RequestInit) {\n  try {\n    return await fetchJson(url, data, init);\n  } catch (err) {\n    if (err instanceof ApiServerError && (!err.statusCode || err.statusCode === 403)) {\n      return fetchJson(`${BRILLIANT_API_BASE_URL}/proxy/?url=${url.toString()}`, data, init);\n    }\n    throw err;\n  }\n}\n\nexport async function fetchJson(url: string | URL, data?: QueryParams, init?: RequestInit) {\n  const urlObject = new URL(url);\n  if (data) {\n    Object.entries(data).forEach(([key, value]) => {\n      if (value === undefined) {\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach((item) => {\n          urlObject.searchParams.append(key, item.toString());\n        });\n      } else {\n        urlObject.searchParams.set(key, value.toString());\n      }\n    });\n  }\n\n  const response = await fetchWithRetry(urlObject, init);\n\n  return response.json();\n}\n\nexport async function fetchWithRetry(url: string | URL, init?: RequestInit, options?: {\n  retries?: number;\n  timeouts?: number | number[];\n  shouldSkipRetryFn?: (message?: string, statusCode?: number) => boolean;\n}) {\n  const {\n    retries = DEFAULT_RETRIES,\n    timeouts = DEFAULT_TIMEOUT,\n    shouldSkipRetryFn = isNotTemporaryError,\n  } = options ?? {};\n\n  let message = 'Unknown error.';\n  let statusCode: number | undefined;\n\n  for (let i = 1; i <= retries; i++) {\n    try {\n      if (i > 1) {\n        logDebug(`Retry request #${i}:`, url.toString(), statusCode);\n      }\n\n      const timeout = Array.isArray(timeouts)\n        ? timeouts[i - 1] ?? timeouts[timeouts.length - 1]\n        : Math.min(timeouts * i, MAX_TIMEOUT);\n      const response = await fetchWithTimeout(url, init, timeout);\n      statusCode = response.status;\n\n      if (statusCode >= 400) {\n        const { error } = await response.json().catch(() => {});\n        throw new Error(error ?? `HTTP Error ${statusCode}`);\n      }\n\n      return response;\n    } catch (err: any) {\n      message = typeof err === 'string' ? err : err.message ?? message;\n\n      const shouldSkipRetry = shouldSkipRetryFn(message, statusCode);\n\n      if (shouldSkipRetry) {\n        throw new ApiServerError(message, statusCode);\n      }\n\n      if (i < retries) {\n        await pause(DEFAULT_ERROR_PAUSE * i);\n      }\n    }\n  }\n\n  throw new ApiServerError(message);\n}\n\nexport async function fetchWithTimeout(url: string | URL, init?: RequestInit, timeout = DEFAULT_TIMEOUT) {\n  const controller = new AbortController();\n  const id = setTimeout(() => {\n    controller.abort();\n  }, timeout);\n\n  try {\n    return await fetch(url, {\n      ...init,\n      signal: controller.signal,\n      cache: 'no-cache', // TODO Remove it after a few releases\n    });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nexport async function handleFetchErrors(response: Response, ignoreHttpCodes?: number[]) {\n  if (!response.ok && (!ignoreHttpCodes?.includes(response.status))) {\n    // eslint-disable-next-line prefer-const\n    let { error, errors } = await response.json().catch(() => undefined);\n    if (!error && errors && errors.length) {\n      error = errors[0]?.msg;\n    }\n\n    throw new ApiServerError(error ?? `HTTP Error ${response.status}`, response.status);\n  }\n  return response;\n}\n\nfunction isNotTemporaryError(message?: string, statusCode?: number) {\n  return statusCode && [400, 404].includes(statusCode);\n}\n","import type { OpenedContract } from '@ton/core';\nimport {\n  Address, beginCell, Builder, Cell, Dictionary,\n} from '@ton/core';\nimport { WalletContractV1R1 } from '@ton/ton/dist/wallets/WalletContractV1R1';\nimport { WalletContractV1R2 } from '@ton/ton/dist/wallets/WalletContractV1R2';\nimport { WalletContractV1R3 } from '@ton/ton/dist/wallets/WalletContractV1R3';\nimport { WalletContractV2R1 } from '@ton/ton/dist/wallets/WalletContractV2R1';\nimport { WalletContractV2R2 } from '@ton/ton/dist/wallets/WalletContractV2R2';\nimport { WalletContractV3R1 } from '@ton/ton/dist/wallets/WalletContractV3R1';\nimport { WalletContractV3R2 } from '@ton/ton/dist/wallets/WalletContractV3R2';\nimport { WalletContractV4 } from '@ton/ton/dist/wallets/WalletContractV4';\nimport { WalletContractV5R1 } from '@ton/ton/dist/wallets/WalletContractV5R1';\n\nimport type { ApiNetwork } from '../../../types';\nimport type { ApiTonWalletVersion, TokenTransferBodyParams } from '../types';\n\nimport {\n  DEFAULT_TIMEOUT,\n  TONCENTER_MAINNET_KEY,\n  TONCENTER_MAINNET_URL,\n  TONCENTER_TESTNET_KEY,\n  TONCENTER_TESTNET_URL,\n} from '../../../../config';\nimport { getDnsZoneByCollection } from '../../../../util/dns';\nimport { fromKeyValueArrays, mapValues } from '../../../../util/iteratees';\nimport { logDebugError } from '../../../../util/logs';\nimport withCacheAsync from '../../../../util/withCacheAsync';\nimport { DnsItem } from '../contracts/DnsItem';\nimport { JettonMinter } from '../contracts/JettonMaster';\nimport { JettonStakingOpCodes } from '../contracts/JettonStaking/imports/constants';\nimport { StakeWallet } from '../contracts/JettonStaking/StakeWallet';\nimport { StakingPool } from '../contracts/JettonStaking/StakingPool';\nimport { JettonWallet } from '../contracts/JettonWallet';\nimport { hexToBytes } from '../../../common/utils';\nimport { getEnvironment } from '../../../environment';\nimport {\n  DEFAULT_IS_BOUNCEABLE,\n  JettonOpCode,\n  LiquidStakingOpCode,\n  OpCode,\n  WORKCHAIN,\n} from '../constants';\nimport { generateQueryId } from './index';\n\nimport { TonClient } from './TonClient';\n\nexport type TonWalletType = typeof WalletContractV1R1\n| typeof WalletContractV1R2\n| typeof WalletContractV1R3\n| typeof WalletContractV2R1\n| typeof WalletContractV2R2\n| typeof WalletContractV3R1\n| typeof WalletContractV3R2\n| typeof WalletContractV4\n| typeof WalletContractV5R1;\n\nexport type TonWallet = OpenedContract<WalletContractV1R1\n| WalletContractV1R2\n| WalletContractV1R3\n| WalletContractV2R1\n| WalletContractV2R2\n| WalletContractV3R1\n| WalletContractV3R2\n| WalletContractV4\n| WalletContractV5R1>;\n\nconst TON_MAX_COMMENT_BYTES = 127;\n\nlet clientByNetwork: Record<ApiNetwork, TonClient> | undefined;\n\nexport const walletClassMap: Record<ApiTonWalletVersion, TonWalletType> = {\n  simpleR1: WalletContractV1R1,\n  simpleR2: WalletContractV1R2,\n  simpleR3: WalletContractV1R3,\n  v2R1: WalletContractV2R1,\n  v2R2: WalletContractV2R2,\n  v3R1: WalletContractV3R1,\n  v3R2: WalletContractV3R2,\n  v4R2: WalletContractV4,\n  W5: WalletContractV5R1,\n};\n\nexport function getTonClient(network: ApiNetwork = 'mainnet') {\n  if (!clientByNetwork) {\n    clientByNetwork = {\n      mainnet: new TonClient({\n        endpoint: `${TONCENTER_MAINNET_URL}/api/v2/jsonRPC`,\n        timeout: DEFAULT_TIMEOUT,\n        apiKey: TONCENTER_MAINNET_KEY,\n        headers: getEnvironment().apiHeaders,\n      }),\n      testnet: new TonClient({\n        endpoint: `${TONCENTER_TESTNET_URL}/api/v2/jsonRPC`,\n        timeout: DEFAULT_TIMEOUT,\n        apiKey: TONCENTER_TESTNET_KEY,\n        headers: getEnvironment().apiHeaders,\n      }),\n    };\n  }\n\n  return clientByNetwork[network];\n}\n\nexport function getTonWalletContract(publicKeyHex: string, version: ApiTonWalletVersion) {\n  const walletClass = walletClassMap[version];\n  if (!walletClass) {\n    throw new Error('Unsupported wallet contract version');\n  }\n\n  const publicKey = Buffer.from(hexToBytes(publicKeyHex));\n  return walletClass.create({ workchain: WORKCHAIN, publicKey });\n}\n\nexport const resolveTokenWalletAddress = withCacheAsync(\n  async (network: ApiNetwork, address: string, tokenAddress: string) => {\n    const minter = getTonClient(network).open(new JettonMinter(Address.parse(tokenAddress)));\n    const walletAddress = await minter.getWalletAddress(Address.parse(address));\n    return toBase64Address(walletAddress, true, network);\n  },\n);\n\nexport const resolveTokenAddress = withCacheAsync(async (network: ApiNetwork, tokenWalletAddress: string) => {\n  const tokenWallet = getTonClient(network).open(new JettonWallet(Address.parse(tokenWalletAddress)));\n  const data = await tokenWallet.getWalletData();\n  return toBase64Address(data.minter, true, network);\n});\n\nexport const getWalletPublicKey = withCacheAsync(async (network: ApiNetwork, address: string) => {\n  try {\n    const res = await getTonClient(network).callGetMethod(Address.parse(address), 'get_public_key');\n    const bigintKey = res.stack.readBigNumber();\n    const hex = bigintKey.toString(16).padStart(64, '0');\n    return hexToBytes(hex);\n  } catch (err) {\n    logDebugError('getWalletPublicKey', err);\n    return undefined;\n  }\n});\n\nexport const getJettonPoolStakeWallet = withCacheAsync(async (\n  network: ApiNetwork,\n  poolAddress: string,\n  period: number,\n  address: string,\n): Promise<OpenedContract<StakeWallet>> => {\n  const tonClient = getTonClient(network);\n  const pool = tonClient.open(StakingPool.createFromAddress(Address.parse(poolAddress)));\n  const walletAddress = (await pool.getWalletAddress(Address.parse(address), period))!;\n  return tonClient.open(StakeWallet.createFromAddress(walletAddress));\n});\n\nexport function getJettonMinterData(network: ApiNetwork, address: string) {\n  const contract = getTonClient(network).open(new JettonMinter(Address.parse(address)));\n  return contract.getJettonData();\n}\n\nexport function oneCellFromBoc(bytes: Uint8Array) {\n  return Cell.fromBoc(Buffer.from(bytes));\n}\n\nexport function toBase64Address(address: Address | string, isBounceable = DEFAULT_IS_BOUNCEABLE, network?: ApiNetwork) {\n  if (typeof address === 'string') {\n    address = Address.parse(address);\n  }\n  return address.toString({\n    urlSafe: true,\n    bounceable: isBounceable,\n    testOnly: network === 'testnet',\n  });\n}\n\nexport function toRawAddress(address: Address | string) {\n  if (typeof address === 'string') {\n    address = Address.parse(address);\n  }\n  return address.toRawString();\n}\n\nexport function buildTokenTransferBody(params: TokenTransferBodyParams) {\n  const {\n    queryId,\n    tokenAmount,\n    toAddress,\n    responseAddress,\n    forwardAmount,\n    customPayload,\n  } = params;\n  let forwardPayload = params.forwardPayload;\n\n  let builder = new Builder()\n    .storeUint(JettonOpCode.Transfer, 32)\n    .storeUint(queryId || generateQueryId(), 64)\n    .storeCoins(tokenAmount)\n    .storeAddress(Address.parse(toAddress))\n    .storeAddress(Address.parse(responseAddress))\n    .storeMaybeRef(customPayload)\n    .storeCoins(forwardAmount ?? 0n);\n\n  if (forwardPayload instanceof Uint8Array) {\n    const freeBytes = Math.round(builder.availableBits / 8);\n    forwardPayload = packBytesAsSnake(forwardPayload, freeBytes);\n  }\n\n  if (!forwardPayload) {\n    builder.storeBit(false);\n  } else if (typeof forwardPayload === 'string') {\n    builder = builder.storeBit(false)\n      .storeUint(0, 32)\n      .storeBuffer(Buffer.from(forwardPayload));\n  } else if (forwardPayload instanceof Uint8Array) {\n    builder = builder.storeBit(false)\n      .storeBuffer(Buffer.from(forwardPayload));\n  } else {\n    builder = builder.storeBit(true)\n      .storeRef(forwardPayload);\n  }\n\n  return builder.endCell();\n}\n\nexport function parseBase64(base64: string) {\n  try {\n    return Cell.fromBase64(base64);\n  } catch (err) {\n    logDebugError('parseBase64', err);\n    return Uint8Array.from(Buffer.from(base64, 'base64'));\n  }\n}\n\nexport function commentToBytes(comment: string): Uint8Array {\n  const buffer = Buffer.from(comment);\n  const bytes = new Uint8Array(buffer.length + 4);\n\n  const startBuffer = Buffer.alloc(4);\n  startBuffer.writeUInt32BE(OpCode.Comment);\n  bytes.set(startBuffer, 0);\n  bytes.set(buffer, 4);\n\n  return bytes;\n}\n\nexport function packBytesAsSnake(bytes: Uint8Array, maxBytes = TON_MAX_COMMENT_BYTES): Uint8Array | Cell {\n  const buffer = Buffer.from(bytes);\n  if (buffer.length <= maxBytes) {\n    return bytes;\n  }\n\n  return packBytesAsSnakeCell(bytes);\n}\n\nexport function packBytesAsSnakeCell(bytes: Uint8Array): Cell {\n  const bytesPerCell = TON_MAX_COMMENT_BYTES;\n  const cellCount = Math.ceil(bytes.length / bytesPerCell);\n  let headCell: Cell | undefined;\n\n  for (let i = cellCount - 1; i >= 0; i--) {\n    const cellOffset = i * bytesPerCell;\n    const cellLength = Math.min(bytesPerCell, bytes.length - cellOffset);\n    const cellBuffer = Buffer.from(bytes.buffer, bytes.byteOffset + cellOffset, cellLength); // This creates a buffer that references the input bytes instead of copying them\n\n    const nextHeadCell = new Builder().storeBuffer(cellBuffer);\n    if (headCell) {\n      nextHeadCell.storeRef(headCell);\n    }\n    headCell = nextHeadCell.endCell();\n  }\n\n  return headCell ?? Cell.EMPTY;\n}\n\nexport function packBytesAsSnakeForEncryptedData(data: Uint8Array): Uint8Array | Cell {\n  const ROOT_BUILDER_BYTES = 39;\n  const MAX_CELLS_AMOUNT = 16;\n\n  if (data.length > ROOT_BUILDER_BYTES + MAX_CELLS_AMOUNT * TON_MAX_COMMENT_BYTES) {\n    throw new Error('Input text is too long');\n  }\n\n  return new Builder()\n    .storeBuffer(Buffer.from(data.subarray(0, ROOT_BUILDER_BYTES)))\n    .storeRef(packBytesAsSnakeCell(data.subarray(ROOT_BUILDER_BYTES)))\n    .endCell();\n}\n\nexport function buildLiquidStakingDepositBody(queryId?: number) {\n  return new Builder()\n    .storeUint(LiquidStakingOpCode.Deposit, 32)\n    .storeUint(queryId || 0, 64)\n    .asCell();\n}\n\nexport function buildLiquidStakingWithdrawBody(options: {\n  queryId?: number;\n  amount: bigint;\n  responseAddress: string;\n  waitTillRoundEnd?: boolean; // opposite of request_immediate_withdrawal\n  fillOrKill?: boolean;\n}) {\n  const {\n    queryId, amount, responseAddress, waitTillRoundEnd, fillOrKill,\n  } = options;\n\n  const customPayload = buildLiquidStakingWithdrawCustomPayload(waitTillRoundEnd, fillOrKill);\n\n  return new Builder()\n    .storeUint(JettonOpCode.Burn, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeCoins(amount)\n    .storeAddress(Address.parse(responseAddress))\n    .storeBit(1)\n    .storeRef(customPayload)\n    .asCell();\n}\n\nexport function buildLiquidStakingWithdrawCustomPayload(waitTillRoundEnd?: boolean, fillOrKill?: boolean) {\n  return new Builder()\n    .storeUint(Number(waitTillRoundEnd), 1)\n    .storeUint(Number(fillOrKill), 1)\n    .asCell();\n}\n\nexport function getTokenBalance(network: ApiNetwork, walletAddress: string) {\n  const tokenWallet = getTonClient(network).open(new JettonWallet(Address.parse(walletAddress)));\n  return tokenWallet.getJettonBalance();\n}\n\nexport function parseAddress(address: string): {\n  isValid: boolean;\n  isRaw?: boolean;\n  isUserFriendly?: boolean;\n  isBounceable?: boolean;\n  isTestOnly?: boolean;\n  address?: Address;\n} {\n  try {\n    if (Address.isRaw(address)) {\n      return {\n        address: Address.parseRaw(address),\n        isRaw: true,\n        isValid: true,\n      };\n    } else if (Address.isFriendly(address)) {\n      return {\n        ...Address.parseFriendly(address),\n        isUserFriendly: true,\n        isValid: true,\n      };\n    }\n  } catch (err) {\n    // Do nothing\n  }\n\n  return { isValid: false };\n}\n\nexport function getIsRawAddress(address: string) {\n  return Boolean(parseAddress(address).isRaw);\n}\n\nexport async function getDnsItemDomain(network: ApiNetwork, address: Address | string) {\n  if (typeof address === 'string') address = Address.parse(address);\n\n  const contract = getTonClient(network)\n    .open(new DnsItem(address));\n  const nftData = await contract.getNftData();\n  const collectionAddress = toBase64Address(nftData.collectionAddress, true);\n\n  const zone = getDnsZoneByCollection(collectionAddress);\n\n  const base = zone?.isTelemint\n    ? await contract.getTelemintDomain()\n    : await contract.getDomain();\n\n  return `${base}.${zone?.suffixes[0]}`;\n}\n\nexport function buildJettonUnstakePayload(jettonsToUnstake: bigint, forceUnstake?: boolean, queryId?: bigint) {\n  return beginCell()\n    .storeUint(JettonStakingOpCodes.UNSTAKE_JETTONS, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeCoins(jettonsToUnstake)\n    .storeBit(forceUnstake ?? false)\n    .endCell();\n}\n\nexport function buildJettonClaimPayload(poolWallets: string[], queryId?: bigint) {\n  const rewardsToClaim = Dictionary.empty(Dictionary.Keys.Address(), Dictionary.Values.Bool());\n\n  for (const poolWallet of poolWallets) {\n    rewardsToClaim.set(Address.parse(poolWallet), true);\n  }\n\n  return beginCell()\n    .storeUint(JettonStakingOpCodes.CLAIM_REWARDS, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeDict(rewardsToClaim, Dictionary.Keys.Address(), Dictionary.Values.Bool())\n    .endCell();\n}\n\nexport function unpackDicts(obj: Record<string, any | Dictionary<any, any>>): AnyLiteral {\n  if (!isSimpleObject(obj)) {\n    return obj;\n  }\n\n  return mapValues(obj, (value) => {\n    if (value instanceof Dictionary) {\n      return unpackDicts(fromKeyValueArrays(value.keys(), value.values()));\n    }\n    if (isSimpleObject(value)) {\n      return unpackDicts(value);\n    }\n    return value;\n  });\n}\n\nfunction isSimpleObject(obj: any) {\n  // eslint-disable-next-line no-null/no-null\n  return obj !== null\n    && typeof obj === 'object'\n    && Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nexport function getOurFeePayload() {\n  return new Builder()\n    .storeUint(OpCode.OurFee, 32)\n    .endCell();\n}\n","import { STAKING_POOLS } from '../../config';\n\nexport function sha256(bytes: Uint8Array) {\n  return crypto.subtle.digest('SHA-256', bytes);\n}\n\nexport function bytesToHex(bytes: Uint8Array) {\n  return Buffer.from(bytes).toString('hex');\n}\n\nexport function hexToBytes(hex: string) {\n  return Uint8Array.from(Buffer.from(hex, 'hex'));\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  return Buffer.from(bytes).toString('base64');\n}\n\nexport function base64ToBytes(base64: string) {\n  return Uint8Array.from(Buffer.from(base64, 'base64'));\n}\n\nexport function base64ToString(base64: string) {\n  return Buffer.from(base64, 'base64').toString('utf-8');\n}\n\nexport function isKnownStakingPool(address: string) {\n  return STAKING_POOLS.some((poolPart) => address.endsWith(poolPart));\n}\n","export default function compareVersions(versionA: string, versionB: string): -1 | 0 | 1 {\n  const partsA = versionA.split('.').map(Number);\n  const partsB = versionB.split('.').map(Number);\n\n  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n    const partA = partsA[i] || 0;\n    const partB = partsB[i] || 0;\n\n    if (partA > partB) return 1;\n    if (partA < partB) return -1;\n  }\n\n  return 0;\n}\n","import { StatusCodes } from '@ledgerhq/errors';\nimport TransportWebHID from '@ledgerhq/hw-transport-webhid';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport type { StateInit } from '@ton/core';\nimport { loadStateInit } from '@ton/core';\nimport type { TonPayloadFormat } from '@ton-community/ton-ledger';\nimport { KNOWN_JETTONS, parseMessage, TonTransport } from '@ton-community/ton-ledger';\nimport type { HIDTransport } from 'mtw-capacitor-usb-hid';\nimport { Address } from '@ton/core/dist/address/Address';\nimport { Builder } from '@ton/core/dist/boc/Builder';\nimport { Cell } from '@ton/core/dist/boc/Cell';\nimport { SendMode } from '@ton/core/dist/types/SendMode';\n\nimport type { Workchain } from '../../api/chains/ton';\nimport type { ApiSubmitTransferOptions } from '../../api/methods/types';\nimport type { ApiTonConnectProof } from '../../api/tonConnect/types';\nimport type {\n  ApiJettonStakingState,\n  ApiLocalTransactionParams,\n  ApiNetwork,\n  ApiNft,\n  ApiSignedTransfer,\n  ApiStakingState,\n  ApiTransferToSign,\n} from '../../api/types';\nimport type BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\nimport type { LedgerTransport, LedgerWalletInfo } from './types';\nimport { ApiLiquidUnstakeMode, ApiTransactionError } from '../../api/types';\n\nimport {\n  BURN_ADDRESS, IS_CAPACITOR, LIQUID_JETTON, LIQUID_POOL,\n  NOTCOIN_EXCHANGERS, NOTCOIN_VOUCHERS_ADDRESS, TONCOIN,\n} from '../../config';\nimport { callApi } from '../../api';\nimport {\n  DEFAULT_IS_BOUNCEABLE,\n  NFT_TRANSFER_AMOUNT,\n  NFT_TRANSFER_FORWARD_AMOUNT,\n  STAKE_COMMENT,\n  TOKEN_TRANSFER_FORWARD_AMOUNT,\n  TON_GAS,\n  TRANSFER_TIMEOUT_SEC,\n  UNSTAKE_COMMENT,\n  WALLET_IS_BOUNCEABLE,\n  WORKCHAIN,\n} from '../../api/chains/ton/constants';\nimport {\n  buildJettonClaimPayload,\n  buildJettonUnstakePayload,\n  buildLiquidStakingWithdrawCustomPayload,\n  commentToBytes,\n  packBytesAsSnakeCell,\n  toBase64Address,\n} from '../../api/chains/ton/util/tonCore';\nimport {\n  ApiHardwareBlindSigningNotEnabled,\n  ApiUnsupportedVersionError,\n  ApiUserRejectsError,\n  handleServerError,\n} from '../../api/errors';\nimport { parseAccountId } from '../account';\nimport compareVersions from '../compareVersions';\nimport { logDebugError } from '../logs';\nimport { pause } from '../schedulers';\nimport { IS_ANDROID_APP } from '../windowEnvironment';\nimport { isLedgerConnectionBroken, isValidLedgerComment } from './utils';\n\nimport { StakingPool } from '../../api/chains/ton/contracts/JettonStaking/StakingPool';\n\ntype BleConnectorClass = typeof import('./bleConnector').BleConnector;\ntype HIDTransportClass = typeof import('mtw-capacitor-usb-hid/dist/esm').HIDTransport;\ntype ListLedgerDevicesFunction = typeof import('mtw-capacitor-usb-hid/dist/esm').listLedgerDevices;\n\ntype TransactionParams = {\n  to: Address;\n  sendMode: SendMode;\n  seqno: number;\n  timeout: number;\n  bounce: boolean;\n  amount: bigint;\n  stateInit?: StateInit;\n  payload?: TonPayloadFormat;\n  walletSpecifiers?: {\n    subwalletId?: number;\n    includeWalletOp: boolean;\n  };\n};\n\nexport type PossibleWalletVersion = 'v3R2' | 'v4R2';\n\nenum LedgerWalletVersion {\n  v3R2 = 'v3r2',\n  v4R2 = 'v4',\n}\n\nconst INTERNAL_WORKCHAIN = 0; // workchain === -1 ? 255 : 0;\nconst DEFAULT_WALLET_VERSION: PossibleWalletVersion = 'v4R2';\n\nconst ATTEMPTS = 10;\nconst PAUSE = 125;\nconst IS_BOUNCEABLE = false;\nconst VERSION_WITH_UNSAFE = '2.1.0';\nconst VERSION_WITH_JETTON_ID = '2.2.0';\nconst VESTING_SUBWALLET_ID = 0x10C;\n\nconst knownJettonAddresses = KNOWN_JETTONS.map(\n  ({ masterAddress }) => masterAddress.toString({ bounceable: true, urlSafe: true }),\n);\n\nlet transport: TransportWebHID | TransportWebUSB | BleTransport | HIDTransport | undefined;\nlet tonTransport: TonTransport | undefined;\nlet isHidSupported = false;\nlet isWebUsbSupported = false;\nlet isBluetoothSupported = false;\nlet currentLedgerTransport: LedgerTransport | undefined;\n\nlet hidImportPromise: Promise<{\n  transport: HIDTransportClass;\n  listLedgerDevices: ListLedgerDevicesFunction;\n}>;\nlet bleImportPromise: Promise<BleConnectorClass>;\nlet BleConnector: BleConnectorClass;\nlet MtwHidTransport: HIDTransportClass;\nlet listLedgerDevices: ListLedgerDevicesFunction;\n\nasync function ensureBleConnector() {\n  if (!IS_CAPACITOR) return undefined;\n\n  if (!bleImportPromise) {\n    bleImportPromise = import('./bleConnector').then((module) => {\n      return module.BleConnector;\n    });\n    BleConnector = await bleImportPromise;\n  }\n\n  return bleImportPromise;\n}\n\nasync function ensureHidTransport() {\n  if (!IS_ANDROID_APP) return undefined;\n\n  if (!hidImportPromise) {\n    hidImportPromise = import('mtw-capacitor-usb-hid/dist/esm').then((module) => {\n      return {\n        transport: module.HIDTransport,\n        listLedgerDevices: module.listLedgerDevices,\n      };\n    });\n    const result = await hidImportPromise;\n    MtwHidTransport = result.transport;\n    listLedgerDevices = result.listLedgerDevices;\n  }\n\n  return hidImportPromise;\n}\n\nvoid ensureBleConnector();\nvoid ensureHidTransport();\n\nexport async function detectAvailableTransports() {\n  await ensureBleConnector();\n  await ensureHidTransport();\n  [isHidSupported, isBluetoothSupported, isWebUsbSupported] = await Promise.all([\n    IS_ANDROID_APP ? MtwHidTransport.isSupported() : TransportWebHID.isSupported(),\n    BleConnector ? BleConnector.isSupported() : Promise.resolve(false),\n    TransportWebUSB.isSupported(),\n  ]);\n\n  return {\n    isUsbAvailable: isHidSupported || isWebUsbSupported,\n    isBluetoothAvailable: isBluetoothSupported,\n  };\n}\n\nfunction getInternalWalletVersion(version: PossibleWalletVersion) {\n  return LedgerWalletVersion[version];\n}\n\nexport async function importLedgerWallet(network: ApiNetwork, accountIndex: number) {\n  const walletInfo = await getLedgerWalletInfo(network, accountIndex);\n  return callApi('importLedgerWallet', network, walletInfo);\n}\n\nexport async function reconnectLedger() {\n  try {\n    if (await tonTransport?.isAppOpen()) {\n      return true;\n    }\n  } catch {\n    // Do nothing\n  }\n\n  const isLedgerConnected = await connectLedger();\n  if (!isLedgerConnected) return false;\n\n  try {\n    return await waitLedgerTonApp();\n  } catch (err: any) {\n    if (isLedgerConnectionBroken(err.name)) {\n      return reconnectLedger();\n    }\n\n    throw err;\n  }\n}\n\nexport async function connectLedger(preferredTransport?: LedgerTransport) {\n  if (preferredTransport) currentLedgerTransport = preferredTransport;\n\n  try {\n    switch (currentLedgerTransport) {\n      case 'bluetooth':\n        transport = await connectBLE();\n        break;\n\n      case 'usb':\n      default:\n        if (isHidSupported) {\n          transport = await connectHID();\n        } else if (isWebUsbSupported) {\n          transport = await connectWebUsb();\n        }\n        break;\n    }\n\n    if (!transport) {\n      logDebugError('connectLedger: BLE and/or HID are not supported');\n      return false;\n    }\n\n    tonTransport = new TonTransport(transport);\n    return true;\n  } catch (err) {\n    logDebugError('connectLedger', err);\n    return false;\n  }\n}\n\nfunction waitLedgerTonAppDeadline(): Promise<boolean> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(false);\n    }, PAUSE * ATTEMPTS);\n  });\n}\n\nexport async function checkTonApp() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    try {\n      const isTonOpen = await tonTransport?.isAppOpen();\n\n      if (isTonOpen) {\n        if (transport?.deviceModel?.id.startsWith('nanoS')) {\n          // Workaround for Ledger Nano S or Nano S Plus, this is a way to check if it is unlocked.\n          // There will be an error with code 0x530c.\n          await tonTransport?.getAddress(getLedgerAccountPathByIndex(0), {\n            walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n          });\n        }\n\n        return true;\n      }\n    } catch (err: any) {\n      if (isLedgerConnectionBroken(err.name)) {\n        tonTransport = undefined;\n        throw err;\n      }\n      if (!err?.message.includes('0x530c')) {\n        logDebugError('waitLedgerTonApp', err);\n      }\n    }\n\n    await pause(PAUSE);\n  }\n\n  return false;\n}\n\nexport function waitLedgerTonApp() {\n  return Promise.race([\n    checkTonApp(),\n    waitLedgerTonAppDeadline(),\n  ]);\n}\n\nfunction connectHID() {\n  if (IS_ANDROID_APP) {\n    return connectCapacitorHID();\n  }\n\n  return connectWebHID();\n}\n\nasync function connectWebHID() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebHID.list();\n\n    if (!device) {\n      await TransportWebHID.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return new TransportWebHID(device);\n    } else {\n      return TransportWebHID.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectWebUsb() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebUSB.list();\n\n    if (!device) {\n      await TransportWebUSB.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return (await TransportWebUSB.openConnected()) ?? (await TransportWebUSB.request());\n    } else {\n      return TransportWebUSB.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectCapacitorHID(): Promise<HIDTransport> {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await listLedgerDevices();\n\n    if (!device) {\n      await pause(PAUSE);\n      continue;\n    }\n\n    try {\n      return await Promise.race([\n        MtwHidTransport.open(device),\n        new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error()), 1000);\n        }),\n      ]);\n    } catch (error) {\n      await pause(PAUSE);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectBLE(): Promise<BleTransport> {\n  if (!BleConnector) {\n    throw new Error('BLE is not supported on this device.');\n  }\n\n  const connection = await BleConnector.connect();\n  return connection.bleTransport;\n}\n\nexport async function submitLedgerStake(\n  accountId: string,\n  amount: bigint,\n  state: ApiStakingState,\n  realFee?: bigint,\n) {\n  const address = await callApi('fetchAddress', accountId, 'ton');\n\n  let result: string | { error: ApiTransactionError } | undefined;\n  const localTransactionParams: Partial<ApiLocalTransactionParams> = { type: 'stake' };\n\n  switch (state.type) {\n    case 'nominators': {\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: state.pool,\n        amount: amount + TON_GAS.stakeNominators,\n        comment: STAKE_COMMENT,\n        realFee,\n      }, TONCOIN.slug, localTransactionParams);\n      break;\n    }\n    case 'liquid': {\n      const payload: TonPayloadFormat = {\n        type: 'tonstakers-deposit',\n        queryId: 0n,\n        // eslint-disable-next-line no-null/no-null\n        appId: null,\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: LIQUID_POOL,\n        amount: amount + TON_GAS.stakeLiquid,\n        realFee,\n      }, TONCOIN.slug, localTransactionParams, payload);\n      break;\n    }\n    case 'jetton': {\n      const {\n        pool: poolAddress,\n        period,\n        tokenAddress,\n        tokenSlug,\n      } = state;\n\n      Object.assign(localTransactionParams, {\n        inMsgHash: undefined,\n        slug: tokenSlug,\n        toAddress: poolAddress,\n      });\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: poolAddress,\n        tokenAddress,\n        amount,\n        data: StakingPool.stakePayload(period),\n        forwardAmount: TON_GAS.stakeJettonsForward,\n        realFee,\n      }, TONCOIN.slug, localTransactionParams);\n      break;\n    }\n  }\n\n  if (result) {\n    await callApi('updateAccountMemoryCache', accountId, address!, { stakedAt: Date.now() });\n  }\n\n  return result;\n}\n\nexport async function submitLedgerUnstake(accountId: string, state: ApiStakingState, amount: bigint, realFee?: bigint) {\n  const { network } = parseAccountId(accountId);\n  const address = (await callApi('fetchAddress', accountId, 'ton'))!;\n\n  let result: string | { error: ApiTransactionError } | undefined;\n  const localActivityParams: Partial<ApiLocalTransactionParams> = { type: 'unstakeRequest' };\n\n  switch (state.type) {\n    case 'nominators': {\n      const poolAddress = toBase64Address(state.pool, true, network);\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: poolAddress,\n        amount: TON_GAS.unstakeNominators,\n        comment: UNSTAKE_COMMENT,\n        realFee,\n      }, TONCOIN.slug, localActivityParams);\n      break;\n    }\n    case 'liquid': {\n      const tokenWalletAddress = await callApi('resolveTokenWalletAddress', network, address, LIQUID_JETTON);\n      const mode = !state.instantAvailable\n        ? ApiLiquidUnstakeMode.BestRate\n        : ApiLiquidUnstakeMode.Default;\n\n      const fillOrKill = false;\n      const waitTillRoundEnd = mode === ApiLiquidUnstakeMode.BestRate;\n\n      const payload: TonPayloadFormat = {\n        type: 'jetton-burn',\n        queryId: 0n,\n        amount,\n        responseDestination: Address.parse(address),\n        customPayload: buildLiquidStakingWithdrawCustomPayload(fillOrKill, waitTillRoundEnd),\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: tokenWalletAddress!,\n        amount: TON_GAS.unstakeLiquid,\n        realFee,\n      }, TONCOIN.slug, localActivityParams, payload);\n      break;\n    }\n    case 'jetton': {\n      const { stakeWalletAddress } = state;\n      const payload: TonPayloadFormat = {\n        type: 'unsafe',\n        message: buildJettonUnstakePayload(amount, true),\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: stakeWalletAddress,\n        amount: TON_GAS.unstakeJettons,\n        realFee,\n      }, TONCOIN.slug, localActivityParams, payload);\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function submitLedgerStakingClaim(\n  accountId: string,\n  state: ApiJettonStakingState,\n  realFee?: bigint,\n) {\n  const payload: TonPayloadFormat = {\n    type: 'unsafe',\n    message: buildJettonClaimPayload(state.poolWallets!),\n  };\n\n  return submitLedgerTransfer({\n    accountId,\n    amount: TON_GAS.claimJettons,\n    password: '',\n    toAddress: state.stakeWalletAddress,\n    realFee,\n  }, TONCOIN.slug, undefined, payload);\n}\n\nexport async function submitLedgerTransfer(\n  options: ApiSubmitTransferOptions & { data?: Cell },\n  slug: string,\n  localActivityParams?: Partial<ApiLocalTransactionParams>,\n  payload?: TonPayloadFormat,\n) {\n  const {\n    accountId,\n    tokenAddress,\n    comment,\n    realFee,\n    data,\n    forwardAmount,\n  } = options;\n  let { toAddress, amount } = options;\n  const { network } = parseAccountId(accountId);\n\n  const pendingTransferId = await callApi('waitAndCreateTonPendingTransfer', accountId);\n  const fromAddress = await callApi('fetchAddress', accountId, 'ton');\n\n  const [path, walletInfo, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    callApi('getWalletInfo', network, fromAddress!),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n\n  const { seqno, balance } = walletInfo!;\n\n  const parsedAddress = Address.parseFriendly(toAddress);\n  let isBounceable = parsedAddress.isBounceable;\n  const normalizedAddress = parsedAddress.address.toString({ urlSafe: true, bounceable: DEFAULT_IS_BOUNCEABLE });\n\n  const { isUnsafeSupported, isJettonIdSupported } = appInfo;\n\n  if (tokenAddress) {\n    ({ toAddress, amount, payload } = await buildLedgerTokenTransfer({\n      network,\n      tokenAddress,\n      fromAddress: fromAddress!,\n      toAddress,\n      amount,\n      data: comment || data,\n      isJettonIdSupported,\n      forwardAmount,\n    }));\n    isBounceable = true;\n  } else if (comment) {\n    if (isValidLedgerComment(comment)) {\n      payload = { type: 'comment', text: comment };\n    } else if (isUnsafeSupported) {\n      payload = { type: 'unsafe', message: buildCommentPayload(comment) };\n    } else {\n      return {\n        error: ApiTransactionError.NotSupportedHardwareOperation,\n      };\n    }\n  }\n\n  const isFullTonBalance = !tokenAddress && balance === amount;\n\n  const sendMode = isFullTonBalance\n    ? SendMode.CARRY_ALL_REMAINING_BALANCE\n    : SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS;\n\n  const walletSpecifiers = account!.ton.version === 'v3R2'\n    ? { includeWalletOp: false }\n    : undefined;\n\n  try {\n    const signedCell = await tonTransport!.signTransaction(path, {\n      to: Address.parse(toAddress),\n      sendMode,\n      seqno: seqno!,\n      timeout: getTransferExpirationTime(),\n      bounce: isBounceable,\n      amount: BigInt(amount),\n      payload,\n      walletSpecifiers,\n    });\n\n    const message: ApiSignedTransfer = {\n      base64: signedCell.toBoc().toString('base64'),\n      seqno: seqno!,\n      localActivity: {\n        amount: options.amount,\n        fromAddress: fromAddress!,\n        toAddress: normalizedAddress,\n        comment,\n        fee: realFee ?? 0n,\n        slug,\n        ...localActivityParams,\n      },\n    };\n\n    return await callApi('sendSignedTransferMessage', accountId, message, pendingTransferId!);\n  } catch (err: any) {\n    await callApi('cancelPendingTransfer', pendingTransferId!);\n\n    handleLedgerErrors(err);\n    logDebugError('submitLedgerTransfer', err);\n    return undefined;\n  }\n}\n\nexport async function submitLedgerNftTransfer(options: {\n  accountId: string;\n  password: string;\n  nftAddress: string;\n  toAddress: string;\n  comment?: string;\n  nft?: ApiNft;\n  realFee?: bigint;\n}) {\n  const {\n    accountId, nftAddress, comment, nft, realFee,\n  } = options;\n  let { toAddress } = options;\n  const { network } = parseAccountId(accountId);\n\n  const pendingTransferId = await callApi('waitAndCreateTonPendingTransfer', accountId);\n\n  const fromAddress = await callApi('fetchAddress', accountId, 'ton');\n\n  const [path, walletInfo, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    callApi('getWalletInfo', network, fromAddress!),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n\n  if (!appInfo.isUnsafeSupported) {\n    return {\n      error: ApiTransactionError.NotSupportedHardwareOperation,\n    };\n  }\n\n  const { seqno } = walletInfo!;\n\n  const isNotcoinBurn = nft?.collectionAddress === NOTCOIN_VOUCHERS_ADDRESS\n    && (toAddress === BURN_ADDRESS || NOTCOIN_EXCHANGERS.includes(toAddress as any));\n  // eslint-disable-next-line no-null/no-null\n  let forwardPayload: Cell | null = null;\n  let forwardAmount = NFT_TRANSFER_FORWARD_AMOUNT;\n\n  if (isNotcoinBurn) {\n    ({ forwardPayload, toAddress } = buildNotcoinVoucherExchange(nftAddress, nft!.index));\n    forwardAmount = 50000000n;\n  } else if (comment) {\n    forwardPayload = buildCommentPayload(comment);\n  }\n\n  const walletSpecifiers = account!.ton.version === 'v3R2'\n    ? { includeWalletOp: false }\n    : undefined;\n\n  try {\n    const signedCell = await tonTransport!.signTransaction(path, {\n      to: Address.parse(nftAddress),\n      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n      seqno: seqno!,\n      timeout: getTransferExpirationTime(),\n      bounce: true,\n      amount: NFT_TRANSFER_AMOUNT,\n      payload: {\n        type: 'nft-transfer',\n        queryId: 0n,\n        newOwner: Address.parse(toAddress),\n        responseDestination: Address.parse(fromAddress!),\n        // eslint-disable-next-line no-null/no-null\n        customPayload: null,\n        forwardAmount,\n        forwardPayload,\n      },\n      walletSpecifiers,\n    });\n\n    const message: ApiSignedTransfer = {\n      base64: signedCell.toBoc().toString('base64'),\n      seqno: seqno!,\n      localActivity: {\n        amount: 0n, // Regular NFT transfers should have no amount in the activity list\n        fromAddress: fromAddress!,\n        toAddress: options.toAddress,\n        comment,\n        fee: realFee ?? 0n,\n        slug: TONCOIN.slug,\n        nft,\n        normalizedAddress: toBase64Address(nftAddress, true, network),\n      },\n    };\n\n    return await callApi('sendSignedTransferMessage', accountId, message, pendingTransferId!);\n  } catch (error) {\n    await callApi('cancelPendingTransfer', pendingTransferId!);\n\n    logDebugError('submitLedgerNftTransfer', error);\n    return undefined;\n  }\n}\n\nfunction buildNotcoinVoucherExchange(nftAddress: string, nftIndex: number) {\n  // eslint-disable-next-line no-bitwise\n  const first4Bits = Address.parse(nftAddress).hash.readUint8() >> 4;\n  const toAddress = NOTCOIN_EXCHANGERS[first4Bits];\n\n  const forwardPayload = new Builder()\n    .storeUint(0x5fec6642, 32)\n    .storeUint(nftIndex, 64)\n    .endCell();\n\n  return { forwardPayload, toAddress };\n}\n\nexport async function buildLedgerTokenTransfer({\n  network,\n  tokenAddress,\n  fromAddress,\n  toAddress,\n  amount,\n  data,\n  isJettonIdSupported,\n  forwardAmount = TOKEN_TRANSFER_FORWARD_AMOUNT,\n}: {\n  network: ApiNetwork;\n  tokenAddress: string;\n  fromAddress: string;\n  toAddress: string;\n  amount: bigint;\n  data?: string | Cell;\n  isJettonIdSupported?: boolean;\n  forwardAmount?: bigint;\n}) {\n  const tokenWalletAddress = await callApi('resolveTokenWalletAddress', network, fromAddress, tokenAddress);\n  const realTokenAddress = await callApi('resolveTokenAddress', network, tokenWalletAddress!);\n  if (tokenAddress !== realTokenAddress) {\n    throw new Error('Invalid contract');\n  }\n\n  // eslint-disable-next-line no-null/no-null\n  const forwardPayload = typeof data === 'string' ? buildCommentPayload(data) : data ?? null;\n\n  const payload: TonPayloadFormat = {\n    type: 'jetton-transfer',\n    queryId: 0n,\n    amount,\n    destination: Address.parse(toAddress),\n    responseDestination: Address.parse(fromAddress),\n    // eslint-disable-next-line no-null/no-null\n    customPayload: null,\n    forwardAmount,\n    forwardPayload,\n    // eslint-disable-next-line no-null/no-null\n    knownJetton: isJettonIdSupported ? getKnownJettonId(tokenAddress) : null,\n  };\n\n  const tonAmountForTransfer = await callApi('getAmountForTokenTransfer', tokenAddress, false);\n  if (!tonAmountForTransfer) {\n    throw new Error('Couldn\\'t get the TON amount for transfer');\n  }\n\n  let toncoinAmount = tonAmountForTransfer.amount;\n  if (forwardAmount > TOKEN_TRANSFER_FORWARD_AMOUNT) {\n    toncoinAmount += forwardAmount;\n  }\n\n  return {\n    amount: toncoinAmount,\n    toAddress: tokenWalletAddress!,\n    payload,\n  };\n}\n\nfunction getKnownJettonId(tokenAddress: string) {\n  const index = knownJettonAddresses.indexOf(tokenAddress);\n  // eslint-disable-next-line no-null/no-null\n  return index > -1 ? { jettonId: index, workchain: WORKCHAIN } : null;\n}\n\nfunction buildCommentPayload(comment: string) {\n  const bytes = commentToBytes(comment);\n  return packBytesAsSnakeCell(bytes);\n}\n\nexport async function signLedgerTransactions(accountId: string, messages: ApiTransferToSign[], options?: {\n  isTonConnect?: boolean;\n  vestingAddress?: string;\n}): Promise<ApiSignedTransfer[]> {\n  const { isTonConnect, vestingAddress } = options ?? {};\n\n  const { network } = parseAccountId(accountId);\n\n  const [path, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n  const fromAddress = account!.ton.address;\n\n  const { isUnsafeSupported, isJettonIdSupported } = appInfo;\n\n  if (isTonConnect && !isUnsafeSupported) {\n    throw new ApiUnsupportedVersionError('Please update Ledger TON app.');\n  }\n\n  const seqno = await callApi('getWalletSeqno', accountId, vestingAddress);\n  let walletSpecifiers: TransactionParams['walletSpecifiers'];\n  if (account!.ton.version === 'v3R2') {\n    walletSpecifiers = { includeWalletOp: false };\n  }\n  if (vestingAddress) {\n    walletSpecifiers = { subwalletId: VESTING_SUBWALLET_ID, includeWalletOp: false };\n  }\n\n  const preparedParams: TransactionParams[] = await Promise.all(messages.map(async (message, index) => {\n    const {\n      toAddress,\n      amount,\n      stateInit: stateInitBase64,\n      rawPayload,\n    } = message;\n\n    const isBounceable = Address.isFriendly(toAddress)\n      ? Address.parseFriendly(toAddress).isBounceable\n      : DEFAULT_IS_BOUNCEABLE;\n\n    let ledgerPayload: TonPayloadFormat | undefined;\n\n    if (rawPayload) {\n      ledgerPayload = parseMessage(Cell.fromBase64(rawPayload), { disallowModification: true });\n    }\n\n    if (ledgerPayload?.type === 'jetton-transfer') {\n      const tokenAddress = await callApi('resolveTokenAddress', network, toAddress);\n      // eslint-disable-next-line no-null/no-null\n      ledgerPayload.knownJetton = isJettonIdSupported ? getKnownJettonId(tokenAddress!) : null;\n    }\n\n    const stateInit = stateInitBase64 ? loadStateInit(\n      Cell.fromBase64(stateInitBase64).asSlice(),\n    ) : undefined;\n\n    return {\n      to: Address.parse(toAddress),\n      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n      seqno: seqno! + index,\n      timeout: getTransferExpirationTime(),\n      bounce: isBounceable,\n      amount: BigInt(amount),\n      payload: ledgerPayload,\n      walletSpecifiers,\n      stateInit,\n    };\n  }));\n\n  const signedMessages: ApiSignedTransfer[] = [];\n\n  const attempts = ATTEMPTS + preparedParams.length;\n  let index = 0;\n  let attempt = 0;\n\n  while (index < preparedParams.length && attempt < attempts) {\n    const params = preparedParams[index];\n    const message = messages[index];\n\n    try {\n      const base64 = (await tonTransport!.signTransaction(path, params)).toBoc().toString('base64');\n      signedMessages.push({\n        base64,\n        seqno: params.seqno,\n        localActivity: {\n          amount: message.amount,\n          fromAddress: fromAddress!,\n          toAddress: message.toAddress,\n          comment: message.payload?.type === 'comment' ? message.payload.comment : undefined,\n          fee: 0n,\n          slug: TONCOIN.slug,\n        },\n      });\n      index++;\n    } catch (err: any) {\n      handleLedgerErrors(err);\n      logDebugError('signLedgerTransactions', err);\n    }\n    attempt++;\n  }\n\n  return signedMessages;\n}\n\nexport async function signLedgerProof(accountId: string, proof: ApiTonConnectProof): Promise<string> {\n  const path = await getLedgerAccountPath(accountId);\n\n  const { timestamp, domain, payload } = proof;\n\n  const result = await tonTransport!.getAddressProof(path, {\n    domain,\n    timestamp,\n    payload: Buffer.from(payload),\n  });\n  return result.signature.toString('base64');\n}\n\nexport async function getNextLedgerWallets(\n  network: ApiNetwork,\n  lastExistingIndex = -1,\n  alreadyImportedAddresses: string[] = [],\n) {\n  const result: LedgerWalletInfo[] = [];\n  let index = lastExistingIndex + 1;\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const walletInfo = await getLedgerWalletInfo(network, index);\n\n      if (alreadyImportedAddresses.includes(walletInfo.address)) {\n        index += 1;\n        continue;\n      }\n\n      if (walletInfo.balance !== 0n) {\n        result.push(walletInfo);\n        index += 1;\n        continue;\n      }\n\n      if (!result.length) {\n        result.push(walletInfo);\n      }\n\n      return result;\n    }\n  } catch (err) {\n    return handleServerError(err);\n  }\n}\n\nexport async function getLedgerWalletInfo(network: ApiNetwork, accountIndex: number): Promise<LedgerWalletInfo> {\n  const { address, publicKey } = await getLedgerWalletAddress(accountIndex);\n  const balance = (await callApi('getWalletBalance', 'ton', network, address))!;\n\n  return {\n    index: accountIndex,\n    address,\n    publicKey: publicKey!.toString('hex'),\n    balance,\n    version: DEFAULT_WALLET_VERSION,\n    driver: 'HID',\n    deviceId: transport!.deviceModel?.id,\n    deviceName: transport!.deviceModel?.productName,\n  };\n}\n\nexport function getLedgerWalletAddress(index: number, isTestnet?: boolean) {\n  const path = getLedgerAccountPathByIndex(index, isTestnet);\n\n  return tonTransport!.getAddress(path, {\n    chain: INTERNAL_WORKCHAIN,\n    bounceable: WALLET_IS_BOUNCEABLE,\n    walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n  });\n}\n\nexport async function verifyAddress(accountId: string) {\n  const [account, path] = await Promise.all([\n    callApi('fetchLedgerAccount', accountId),\n    getLedgerAccountPath(accountId),\n  ]);\n\n  await tonTransport!.validateAddress(path, {\n    bounceable: IS_BOUNCEABLE,\n    walletVersion: getInternalWalletVersion(account!.ton.version as PossibleWalletVersion),\n  });\n}\n\nasync function getLedgerAccountPath(accountId: string) {\n  const account = await callApi('fetchLedgerAccount', accountId);\n  const index = account!.ton.index;\n\n  return getLedgerAccountPathByIndex(index);\n}\n\nfunction getLedgerAccountPathByIndex(index: number, isTestnet?: boolean, workchain: Workchain = WORKCHAIN) {\n  const network = isTestnet ? 1 : 0;\n  const chain = workchain === -1 ? 255 : 0;\n  return [44, 607, network, chain, index, 0];\n}\n\nfunction getTransferExpirationTime() {\n  return Math.floor(Date.now() / 1000 + TRANSFER_TIMEOUT_SEC);\n}\n\nexport async function getTonAppInfo() {\n  const version = await tonTransport!.getVersion();\n  const isUnsafeSupported = compareVersions(version, VERSION_WITH_UNSAFE) >= 0;\n  const isJettonIdSupported = compareVersions(version, VERSION_WITH_JETTON_ID) >= 0\n    && transport!.deviceModel?.id !== 'nanoS';\n  return { version, isUnsafeSupported, isJettonIdSupported };\n}\n\nfunction handleLedgerErrors(err: any) {\n  if (err?.message.includes('(0xbd00)')) {\n    throw new ApiHardwareBlindSigningNotEnabled();\n  }\n  if (err?.statusCode === StatusCodes.CONDITIONS_OF_USE_NOT_SATISFIED) {\n    throw new ApiUserRejectsError();\n  }\n}\n"],"names":["MAX_TIMEOUT","async","fetchWithRetry","url","init","options","retries","DEFAULT_RETRIES","timeouts","DEFAULT_TIMEOUT","shouldSkipRetryFn","isNotTemporaryError","statusCode","message","i","_timeouts","logDebug","toString","timeout","Array","isArray","length","Math","min","response","fetchWithTimeout","status","error","json","catch","Error","err","_err$message","ApiServerError","pause","DEFAULT_ERROR_PAUSE","arguments","undefined","controller","AbortController","id","setTimeout","abort","fetch","signal","cache","clearTimeout","includes","TON_MAX_COMMENT_BYTES","clientByNetwork","getTonClient","network","mainnet","TonClient","endpoint","TONCENTER_MAINNET_URL","apiKey","TONCENTER_MAINNET_KEY","headers","getEnvironment","apiHeaders","testnet","TONCENTER_TESTNET_URL","TONCENTER_TESTNET_KEY","toBase64Address","address","isBounceable","DEFAULT_IS_BOUNCEABLE","Address","parse","urlSafe","bounceable","testOnly","buildLiquidStakingWithdrawCustomPayload","waitTillRoundEnd","fillOrKill","Builder","storeUint","Number","asCell","buildJettonClaimPayload","poolWallets","queryId","rewardsToClaim","Dictionary","empty","Keys","Values","Bool","poolWallet","set","beginCell","JettonStakingOpCodes","CLAIM_REWARDS","storeDict","endCell","WalletContractV1R1","WalletContractV1R2","WalletContractV1R3","WalletContractV2R1","WalletContractV2R2","WalletContractV3R1","WalletContractV3R2","WalletContractV4","WalletContractV5R1","withCacheAsync","tokenAddress","minter","open","JettonMinter","getWalletAddress","tokenWalletAddress","tokenWallet","JettonWallet","getWalletData","bigintKey","callGetMethod","stack","readBigNumber","hex","padStart","Uint8Array","from","Buffer","logDebugError","poolAddress","period","tonClient","pool","StakingPool","createFromAddress","walletAddress","StakeWallet","compareVersions","versionA","versionB","partsA","split","map","partsB","max","partA","partB","LedgerWalletVersion","INTERNAL_WORKCHAIN","DEFAULT_WALLET_VERSION","ATTEMPTS","PAUSE","IS_BOUNCEABLE","VERSION_WITH_UNSAFE","VERSION_WITH_JETTON_ID","VESTING_SUBWALLET_ID","knownJettonAddresses","KNOWN_JETTONS","_ref","masterAddress","transport","tonTransport","currentLedgerTransport","hidImportPromise","bleImportPromise","BleConnector","MtwHidTransport","listLedgerDevices","isHidSupported","isWebUsbSupported","isBluetoothSupported","ensureBleConnector","IS_CAPACITOR","then","module","ensureHidTransport","IS_ANDROID_APP","HIDTransport","result","detectAvailableTransports","Promise","all","isSupported","TransportWebHID","resolve","TransportWebUSB","isUsbAvailable","isBluetoothAvailable","importLedgerWallet","accountIndex","walletInfo","getLedgerWalletInfo","callApi","reconnectLedger","_tonTransport","isAppOpen","connectLedger","waitLedgerTonApp","isLedgerConnectionBroken","name","preferredTransport","connect","bleTransport","connectBLE","device","race","_","reject","connectCapacitorHID","list","opened","create","connectWebHID","_await$TransportWebUS","openConnected","request","connectWebUsb","TonTransport","checkTonApp","_tonTransport2","_transport","_tonTransport3","deviceModel","startsWith","getAddress","getLedgerAccountPathByIndex","walletVersion","submitLedgerStake","accountId","amount","state","realFee","localTransactionParams","type","submitLedgerTransfer","password","toAddress","TON_GAS","stakeNominators","comment","STAKE_COMMENT","TONCOIN","slug","payload","appId","LIQUID_POOL","stakeLiquid","tokenSlug","Object","assign","inMsgHash","data","stakePayload","forwardAmount","stakeJettonsForward","stakedAt","Date","now","submitLedgerUnstake","parseAccountId","localActivityParams","unstakeNominators","UNSTAKE_COMMENT","LIQUID_JETTON","instantAvailable","ApiLiquidUnstakeMode","Default","BestRate","responseDestination","customPayload","unstakeLiquid","stakeWalletAddress","jettonsToUnstake","forceUnstake","UNSTAKE_JETTONS","storeCoins","storeBit","unstakeJettons","submitLedgerStakingClaim","claimJettons","pendingTransferId","fromAddress","path","appInfo","account","getLedgerAccountPath","getTonAppInfo","seqno","balance","parsedAddress","parseFriendly","normalizedAddress","isUnsafeSupported","isJettonIdSupported","buildLedgerTokenTransfer","isValidLedgerComment","text","ApiTransactionError","NotSupportedHardwareOperation","buildCommentPayload","sendMode","SendMode","PAY_GAS_SEPARATELY","IGNORE_ERRORS","CARRY_ALL_REMAINING_BALANCE","walletSpecifiers","ton","version","includeWalletOp","base64","signTransaction","to","getTransferExpirationTime","bounce","BigInt","toBoc","localActivity","fee","handleLedgerErrors","submitLedgerNftTransfer","nftAddress","nft","isNotcoinBurn","collectionAddress","NOTCOIN_VOUCHERS_ADDRESS","BURN_ADDRESS","NOTCOIN_EXCHANGERS","forwardPayload","NFT_TRANSFER_FORWARD_AMOUNT","nftIndex","first4Bits","hash","readUint8","buildNotcoinVoucherExchange","index","NFT_TRANSFER_AMOUNT","newOwner","_ref2","TOKEN_TRANSFER_FORWARD_AMOUNT","destination","knownJetton","getKnownJettonId","tonAmountForTransfer","toncoinAmount","indexOf","jettonId","workchain","WORKCHAIN","bytes","buffer","startBuffer","alloc","writeUInt32BE","OpCode","Comment","commentToBytes","_headCell","bytesPerCell","headCell","ceil","cellOffset","cellLength","cellBuffer","byteOffset","nextHeadCell","storeBuffer","storeRef","Cell","EMPTY","packBytesAsSnakeCell","signLedgerTransactions","messages","isTonConnect","vestingAddress","ApiUnsupportedVersionError","subwalletId","preparedParams","_ledgerPayload","stateInit","stateInitBase64","rawPayload","isFriendly","ledgerPayload","parseMessage","fromBase64","disallowModification","loadStateInit","asSlice","signedMessages","attempts","attempt","params","_message$payload","push","signLedgerProof","proof","timestamp","domain","getAddressProof","signature","getNextLedgerWallets","alreadyImportedAddresses","handleServerError","_deviceModel","_deviceModel2","publicKey","getLedgerWalletAddress","driver","deviceId","deviceName","productName","isTestnet","chain","WALLET_IS_BOUNCEABLE","verifyAddress","validateAddress","floor","TRANSFER_TIMEOUT_SEC","_deviceModel3","getVersion","ApiHardwareBlindSigningNotEnabled","StatusCodes","CONDITIONS_OF_USE_NOT_SATISFIED","ApiUserRejectsError"],"sourceRoot":""}